/**
 * generate-mission-data.cjs
 *
 * Reads src/data/narrativeScenarios.json and outputs
 * tests/e2e/missions/mission-data.ts with typed mission
 * metadata for E2E mission-completion tests.
 *
 * Usage:  node scripts/generate-mission-data.cjs
 */

const fs = require("fs");
const path = require("path");

const SCENARIOS_PATH = path.resolve(
  __dirname,
  "..",
  "src",
  "data",
  "narrativeScenarios.json",
);
const OUTPUT_PATH = path.resolve(
  __dirname,
  "..",
  "tests",
  "e2e",
  "missions",
  "mission-data.ts",
);

const raw = fs.readFileSync(SCENARIOS_PATH, "utf-8");
const { scenarios } = JSON.parse(raw);

/**
 * Determine step type â€” defaults to "command" when absent.
 */
function stepType(step) {
  if (step.type === "concept") return "concept";
  if (step.type === "observe") return "observe";
  return "command";
}

/**
 * Build a MissionStep from a scenario step.
 */
function toMissionStep(step) {
  const type = stepType(step);
  const hasQuiz = !!step.quiz;

  // Mirror narrativeAdapter.ts: observe steps with observeCommand
  // prepend it to expectedCommands (the user must type it)
  let expectedCommands = step.expectedCommands || [];
  if (type === "observe" && step.observeCommand) {
    expectedCommands = [step.observeCommand, ...expectedCommands];
  }

  const result = {
    id: step.id,
    type,
    expectedCommands,
    hasQuiz,
  };
  if (hasQuiz) {
    result.quizCorrectIndex = step.quiz.correctIndex;
  }
  return result;
}

/**
 * Build a Mission from a scenario.
 */
function toMission(scenario) {
  return {
    id: scenario.id,
    title: scenario.title,
    domain: scenario.domain,
    steps: scenario.steps.map(toMissionStep),
  };
}

const missions = scenarios.map(toMission);

// --- Code generation ---

const header = `// AUTO-GENERATED by scripts/generate-mission-data.cjs
// Do not edit manually. Re-run the script after changing narrativeScenarios.json.

export interface MissionStep {
  id: string;
  type: "command" | "concept" | "observe";
  expectedCommands: string[];
  hasQuiz: boolean;
  quizCorrectIndex?: number;
}

export interface Mission {
  id: string;
  title: string;
  domain: number;
  steps: MissionStep[];
}
`;

function serializeStep(step) {
  const parts = [
    `      id: ${JSON.stringify(step.id)}`,
    `      type: ${JSON.stringify(step.type)}`,
    `      expectedCommands: ${JSON.stringify(step.expectedCommands)}`,
    `      hasQuiz: ${step.hasQuiz}`,
  ];
  if (step.quizCorrectIndex !== undefined) {
    parts.push(`      quizCorrectIndex: ${step.quizCorrectIndex}`);
  }
  return `    {\n${parts.join(",\n")},\n    }`;
}

function serializeMission(mission) {
  const stepsStr = mission.steps.map(serializeStep).join(",\n");
  return [
    `  {`,
    `    id: ${JSON.stringify(mission.id)},`,
    `    title: ${JSON.stringify(mission.title)},`,
    `    domain: ${mission.domain},`,
    `    steps: [\n${stepsStr},\n    ],`,
    `  }`,
  ].join("\n");
}

const body =
  `export const ALL_MISSIONS: Mission[] = [\n` +
  missions.map(serializeMission).join(",\n") +
  `,\n];\n`;

fs.writeFileSync(OUTPUT_PATH, header + "\n" + body, "utf-8");

console.log(
  `Generated ${OUTPUT_PATH} with ${missions.length} missions (${missions.reduce((s, m) => s + m.steps.length, 0)} total steps).`,
);
